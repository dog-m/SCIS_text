%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Тестирование генератора систем инструментирования и анализ результатов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе производится тестирование разработанного прототипа генератора систем автоматизации инструментирования программ и оценка примененных подходов.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Методика испытаний}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Методика испытаний разработанного прототипа генератора систем инструментирования заключается в ручном составлении пользовательских правил инструментирования и последующем применении этих правил к файлу, содержащему текст некоторой программы (целиком или только отдельная часть) при помощи разработанного прототипа (генератора систем инструментирования) с последующим анализом полученного инструментированного текста программы визуально или с помощью вспомогательных средств.
Текст программы перед проведением тестирования подвергается процедуре нормализации без ручного внесения изменений (как предоставляется разработчиком).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Программа испытаний}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Программа испытаний разработанного прототипа заключается в выполнении следующей последовательности операций:

\begin{enumerate}[label=\arabic*]
  \item Выполняется выбор целевых языков программирования.
  \item В соответствии с выбранным набором ЯП производится поиск и подбор проектов с открытым исходым кодом и лицензией, позволяющей вносить изменения лицам, не являющимся членами группы разработки или компании-разработчика.
  \item Для каждого выбранного языка программирования:
    \begin{enumerate}[label*=.\arabic*]
      \item составление библиотеки добавляемых в исходный текст программы фрагментов -- несколько взаимосвязных фрагментов;

      \item поиск существующей грамматики языка;
      \item составление аннотации к выбранной грамматике;
      \item отладка аннотации и грамматики;

      \item ручное написание синтетического тестового исходного кода;
      \item выбор фрагментов исходных текстов из подобранных ранее проектов с открытым исходным кодом с учетом поддержки возможностей ЯП со стороны имеющейся грамматики;
      \item выполнение нормализации исходных текстов при помощи грамматики выбранного языка и утилиты TXL;

      \item осуществляется постановка тестовых задач;
      \item составление пользовательских правил инструментирования для решения поставленной задачи;

      \item выполнение инструментирования при помощи разработанного прототипа;
      \item анализ полученного инструментированного текста программы на соответствие описанным ожиданиям, описанных в виде пользовательских правил инструментирования.
    \end{enumerate}

  \item Общий анализ полученных результатов и оценка возможностей по усовершенствованию разработанного прототипа.
\end{enumerate}

Поиск и оценка изменений выполнялись как визуально, так и с помощью программных средств, таких как консольная <<diffutils>>~\cite{git} и графическая <<TortoiseGitMerge>>~\cite{tortoise-git} утилиты.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Языки программирования}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данной работе было выполнено инструментирование фрагментов исходных текстов нескольких программ, созданных с использованием различных языков программирования общего назначения с разной степенью поддержки структурного программирования.

Для утилиты TXL опубликованы описания грамматик некоторых языков программирования общего назначения, такие как~\cite{txl-resources}:
\begin{multicols}{2}
\begin{itemize}[noitemsep]
  \item TXL
  \item PHP
  \item JavaScript
  \item Ada
  \item ATL
  \item Ada
  \item C\#
  \item Eiffel
  \item Fortran
  \item Modula 3
  \item Ruby
  \item VisualBasic

  \item Java
  \item Python
  \item Object Pascal
  \item С++
\end{itemize}
\end{multicols}

Поскольку некоторые языки обладают схожей степенью строгости применительно к структурному программированию, например: C\# и Java, С++ и PHP, VisualBasic и Object Pascal.
Ниже представлен список рассмотренных ЯП вместе с ключевыми особенностями, по которым был выбран тот или иной язык программирования.

\begin{itemize}[noitemsep]
  \item Java:
    \begin{itemize}[noitemsep]
      \item C-подобный стиль оформления блоков кода (использование символов <<\{>> и <<\}>>);
      \item сильное влияние структурной парадигмы программирования (<<класс>> вложен в <<пакет>>, <<метод>> вложен в <<класс>>);
      \item наличие вложенных структур одного вида (<<класс>> вложен в <<класс>>);
      \item запрет описания функций вне тела класса;
      \item название имени файла совпадает с именем описываемого класса;
      \item запрет на повторное включение зависимостей;
    \end{itemize}

  \item Python:
    \begin{itemize}[noitemsep]
      \item применение различных уровней отступов (символ <<побел>> или <<табуляция>>);
      \item влияние структурной парадигмы программирования (методы описываются в теле классов);
      \item запрет использования блоков кода, оформенных отступами, в середине другого блока кода
      \item различные варианты описания конструкции импорта зависимостей;
    \end{itemize}

  \item С++:
    \begin{itemize}[noitemsep]
      \item C-подобный стиль оформления блоков кода;
      \item применение директив препроцессора;
      \item наличие вложенных структур одного вида (<<класс>> вложен в <<класс>>);
      \item наличие вложенных структур разного вида (<<класс>> вложен в <<функцию>>);
      \item относительно (языка Java) слабое влияние структурной парадигмы программирования (методы класса обычно описываются отдельно от тела самого класса);
      \item вставка кода на другом языке программирования (различные диалекты языка ассемблера);
    \end{itemize}

  \item Object Pascal:
    \begin{itemize}[noitemsep]
      \item использование специальных ключевых слов <<begin>> и <<end>> для оформления блоков кода;
      \item применение директив препроцессора;
      \item наличие вложенных структур одного вида (<<функция>> вложена в <<функцию>>);
      \item наличие вложенных структур разного вида (<<класс>> вложен в <<функцию>>);
      \item опциональное использование символа <<;>> после инструкции или блока кода в зависимости от наличия или отсутствия ветки <<else>> конструкции ветвления;
      \item слабое влияние структурной парадигмы программирования (методы класса описываются отдельно от тела самого класса);
      \item вставка кода на другом языке программирования (различные диалекты языка ассемблера);
      \item запрет на повторное включение зависимостей;
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Проекты с открытым исходным кодом}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В соответствии с программой испытаний для проведения тестирования было выбрано нескоько проектов промышленного уровня с открытым исходным кодом.
Ниже перечислены выбранные проекты:

\begin{itemize}[noitemsep]
  \item AspectJ       \cite{aspectj} --
  система и DSL, предназначенные для реализации принципов аспектно-ориентированного программирования в рамках языка программирования Java.
  Для тестированя была выбрана версия <<1.9.5>>.

  \item Keras library \cite{keras} --
  библиотека-надстройка для высокоуровневой обработки и построения нейосетевых моделей глубинного обучения для языка Python.
  Для тестированя была выбрана версия <<2.3.1>>.

  \item Boost library \cite{boost} --
  многофункциональная модульная библиотека для применения при построении программных продуктов с использованием языка программирования C++.
  Для тестированя была выбрана версия <<1.72.0>>.

  \item Lazarus IDE   \cite{lazarus} --
  графическая кросплатформенная среда быстрой разработки приложений на языке программирования Object Pascal и близких его диалектах.
  Для тестированя была выбрана версия <<2.0.8>>.
\end{itemize}
\nomenclature{IDE}{Integrated Development Environment -- интегрированная среда разработки.}

Выбор проектов основывался на перечисленных выше целевых языках программирования и исходя из возможностей имеющихся на момент написания данной работы грамматик для утилиты TXL~\cite{txl-resources}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Протокол испытаний}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В соответствии с рассмотренной выше программой и методикой испытаний было выполнено тестирование разработанного прототипа генератора систем инструментирования исходного текста программ.
В данной работе не будут рассмотрены тексты созданных аннотаций к представленным в~\cite{txl-resources} грамматикам.
Важно заранее отметить, что некоторые элементы грамматик были незначительно изменены для большего соответствия используемому в разработанном прототипе подходу к задаче инструментирования.
Далее будут приведены тестовые данные вместе с полученными результатами для каждого из выбранных ранее языков программирования.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Java}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Для утилиты TXL существует корректная грамматика~\cite{txl-resources}, описывающая синтаксис языка Java версии <<8>>.
В соответствии с этой грамматикой была вручную написана аннотация для целей инструментирования основных синтетических конструкций.
Фрагменты из этой аннотации были рассмотрены ранее.
Полный текст составленной аннотации в данной работе рассматриваться не будет.

Оценим работоспособность созданного прототипа генератора систем инструментирования в рамках языка Java на примере приложений как тестового, так и промышленного уровня.

%%%%%%%%%%%%%%%%%%%
\subsubsection{Искуственный пример}
%%%%%%%%%%%%%%%%%%%

Одним из первых этапов приведенной выше программы тестирования является проведение инструментирования заранее подготовленного простого тестового приложения.
В листинге~\ref{test-java} приведен исходный текст синтетической тестовой программы для языка Java.

\begin{lstlisting}[frame=single, language=Java, label={test-java}, caption={Исходный текст тестового приложения.}]
package example;
import java.util.logging.Level;
import java.util.logging.ConsoleHandler;

class Main {
  public static int a = -10;
  public static int b = -20;

  public static void something_else(String[] args) {
    if (a >= b) {
      if (a < 0)  System.out.println("Fizz Buzz!");
    }
    if (a >= b) {
      if (a < 0)  System.out.println("Fizz Buzz!");
    }
  }

  public static void main(String[] args) {
    if (a >= b) {
      if (a < 0)  System.out.println("Hello World!");
    }
    if (a >= b) {
      if (a < 0)  System.out.println("Hello World!");
    }
  }
}
\end{lstlisting}

В приведенном тексте программы производится объявление класса с именем <<Main>>, который содержит статические методы с именами <<main>> и <<something\_else>>.
Помимо этого в теле класса представлены целочисленные поля с именами <<a>> и <<b>>.
Каждый объявленный метод содержит несколько вложенных конструкций ветвления <<if>> вместе с несколькими вызовами стандартной функции вывода строки текста в консоль.

Для синтетических тестовых примеров программ на языках Java и Python было составлено общее описание правил инструментирования, полный текст которого приведен в листинге~\ref{test-rules-java-n-python} (форматирование изменено для компактности).
Аналогично были составлены правила для C++ и Object Pascal, которые будут рассмотрены далее.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-java-n-python}, caption={Описание правил инструментирования.}]
use fragment "logging/dependencies"
use fragment "logging/fields"
use fragment "logging/init"
use fragment "logging/message"

context class_m:   { poi:class_name = "Main" }
context method_m:  { poi:method_name matches "mai*" }
context class_and_method_m:  class_m & method_m

rules:
  print_usefull_message_to_the_log:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @class_m -> [first] class # before_body:
      add:  logging_fields

    @class_and_method_m -> [first] method # before_body:
      add:  logging_init

    @class_and_method_m -> [first] if # before:
      make:
        msg <- $std:pointcut + " <" + $std:node + "> block in [" + $poi:class_name + "] class, in {" + $poi:method_name + "} method";
      add:
        logging_message(msg)
\end{lstlisting}

В листинге~\ref{test-java-result} приведен программный код обработанной тестовой программы на языке Java, которая прошла операцию инструментирования при помощи разработанного прототипа генератора систем инструментирования (форматирование изменено для компактности; символ <<+>> в начале строки обозначает строку, которая была добавлена).

\begin{lstlisting}[frame=single, language=Java, label={test-java-result}, caption={Текст инструментированного тестового приложения.}]
package example;
import java.util.logging.Level;
import java.util.logging.ConsoleHandler;
+ import java.util.logging.Logger;
+ import java.util.logging.Handler;
+ import java.lang.invoke.MethodHandles;

class Main {
+ private static final Class iClass = MethodHandles.lookup().lookupClass();
+ private static final Logger iLogger = Logger.getLogger(iClass.getName());
+ private static final Handler iHandler = new ConsoleHandler();
  public static int a = -10;
  public static int b = -20;

  public static void something_else (String [] args) {
    if (a >= b) {
      if (a < 0)  System.out.println ("Fizz Buzz!");
    }
    if (a >= b) {
      if (a < 0)  System.out.println ("Fizz Buzz!");
    }
  }

  public static void main (String [] args) {
+   iHandler.setLevel (Level.ALL);
+   iLogger.addHandler (iHandler);
+   iLogger.setLevel (Level.ALL);
+   {
+     {
+       iLogger.log(Level.FINE, "before <if_statement> block in [Main] class, in {main} method");
        if (a >= b) {
          if (a < 0)  System.out.println ("Hello World!");
        }
+     }
      if (a >= b) {
        if (a < 0)  System.out.println ("Hello World!");
      }
+   }
  }
}
\end{lstlisting}

Из полученного текста программы можно сделать вывод, что инструментирование прошло в точном соответствии с описанными в листинге~\ref{test-rules-java-n-python} пользовательскими правилами.
Кроме того, в этом можно убедиться выполнив сборку и запуск полученной программы (листинг~\ref{test-java-run}; обработанный текст был сохранен в файле <<test\_source\_instrumented.java>>; путь к рабочей директории опущен).

\begin{lstlisting}[frame=single, label={test-java-run}, caption={Результаты сборки и запуска обработанного тестового приложения.}]
~> javac test_source_instrumented.java
~> java -cp .. example.Main
июн 02, 2020 10:16:38 PM example.Main main
FINE: before <if_statement> block in [Main] class, in {main} method
Hello World!
Hello World!
\end{lstlisting}

Из всего перечисленного выше можно сделать заключение об успешном решении поставленной тестовой задачи в рамках языка Java.

%%%%%%%%%%%%%%%%%%%
\subsubsection{Проект производственного уровня}
%%%%%%%%%%%%%%%%%%%

В соответствии с программой тестирования из кодовой базы проекта AspectJ был выбран файл <<asm/src/main/java/org/aspectj/asm/AsmManager.java>> в рамках тестирования разработанного прототипа.
Данный файл исходного текста содержит пример использования важной особенности языка Java -- несколько вложенных классов, таких как, например, <<CanonicalFilePathMap>> и <<ModelInfo>>.

Исходя из содержимого выбранного файла была поставлена следующая задача:
в вложенном в класс <<AsmManager>> классе с именем, начинающимся на <<Model>>, необходимо вывести на консоль или в стандартный журнал сообщение перед началом каждого цикла <<while>>.

Для решения поставленной задачи было составлено правило инструментирования.
В листинге~\ref{test-rules-java} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка Java.
Здесь и далее используемые фрагменты совпадают с описанными ранее тестовым примером~\ref{test-rules-java-n-python} и содержат только фрагменты <<logging/dependencies>>, <<logging/fields>>, <<logging/init>> и <<logging/message>>.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-java}, caption={Описание правил инструментирования. Java-проект.}]
...
context target_class:  { poi:class_name = "AsmManager" }

rules:
  trace_while_loops_in_Model:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @target_class -> [first] class("Model*") # before_body:
      add:  logging_fields

    @target_class -> [first] class("Model*") -> [all] while # before:
      make:  msg <- $std:pointcut + " " + $std:node;
      add:   logging_message(msg)
\end{lstlisting}

В соответствии с приведенной выше программой испытаний далее была выполнена нормализация исходного текста при помощи утилиты TXL и имеющейся грамматики языка Java~\cite{txl-resources}.

Далее подготовленный текст программы был подвергнут процессу инструментирования при помощи разработанного прототипа генератора систем инструментирования.

Полученный текст программы был проанализирован на предмет изменений при помощи утилиты TortoiseGitMerge, в качестве базового файла для которой использовался нормализованный исходный текст.
Обнаруженные изменения точно соответствовали ожиданиям, которые были представлены ранее в виде пользовательских правил инструментирования (листинг~\ref{test-rules-java}): вывод сообщений до блока <<while>>, а также вспомогательные зависимости и используемые поля класса.
При выполнении инструментирования и последующего (визуального) анализа полученного текста каких-либо примечательных особенностей замечено не было.
Полный текст изменений не будет рассмотрен более подробно в этой работе для компактности.

Таким образом, можно сделать заключение о работоспособности разработанного прототипа и состоятельности используемого подхода к задаче инструментирования в рамках языка Java.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Для утилиты TXL существует грамматика~\cite{txl-resources}, описывающая синтаксис языка Python версии <<2.5>> и некоторые элементы из версии <<3.0>>.
В соответствии с этой грамматикой была вручную написана аннотация для целей инструментирования основных синтетических конструкций.
Фрагменты из этой аннотации были рассмотрены ранее.
Полный текст составленной аннотации в данной работе рассматриваться не будет.

Оценим работоспособность созданного прототипа генератора систем инструментирования в рамках языка Python на примере приложений как тестового, так и промышленного уровня.

%%%%%%%%%%%%%%%%%%%
\subsubsection{Искуственный пример}
%%%%%%%%%%%%%%%%%%%

В листинге~\ref{test-python} приведен исходный текст синтетической тестовой программы для языка Python.

\begin{lstlisting}[frame=single, language=Python, label={test-python}, caption={Исходный текст тестового приложения.}]
from logging import *   # alternative form

class Main:
    def __init__(self):
        self.a = -10
        self.b = -20

    def something_else(self, args):
        if self.a >= self.b:
          if self.a < 0:
            print "Fizz Buzz!"
        if self.a >= self.b:
          if self.a < 0:
            print "Fizz Buzz!"

    def main(self, args):
        if self.a >= self.b:
          if self.a < 0:
            print "Hello World!"
        if self.a >= self.b:
          if self.a < 0:
            print "Hello World!"

Main().main({})
\end{lstlisting}

Приведенный в листинге~\ref{test-python} текст программы аналогичен примеру для языка Java из листинга~\ref{test-java}.
Отличия заключаются в отсутствии определения полей и статических методов класса ввиду особенностей языка Python, и использовании соответствующего набора стандартных зависимостей в соответствии с задачей.

Как было указано ранее, для тестовых программ на языках Python и Java использовался один и тот же файл с описание правил инструментирования, но с отличающимися библиотеками фрагментов программного кода.

В листинге~\ref{test-python-result} приведен программный код обработанной тестовой программы на языке Python, которая прошла операцию инструментирования при помощи разработанного прототипа генератора систем инструментирования (форматирование изменено для компактности; символ <<+>> в начале строки обозначает строку, которая была добавлена).

\begin{lstlisting}[frame=single, language=Python, label={test-python-result}, caption={Текст инструментированного тестового приложения.}]
+ import logging
from logging import *

class Main :
    def __init__(self) :
        self.a = - 10
        self.b = - 20

    def something_else(self, args) :
        if self.a >= self.b :
            if self.a < 0 :
                print "Fizz Buzz!"
        if self.a >= self.b :
            if self.a < 0 :
                print "Fizz Buzz!"

    def main(self, args) :
+       logging.basicConfig()
+       self.iLogger = logging.getLogger("simpleExample")
+       self.iLogger.setLevel(logging.DEBUG)
+       self.iLogger.info("before <if_statement> block in [Main] class, in {main} method")
        if self.a >= self.b :
            if self.a < 0 :
                print "Hello World!"
        if self.a >= self.b :
            if self.a < 0 :
                print "Hello World!"

Main().main({})
\end{lstlisting}

Из полученного текста программы можно сделать вывод, что инструментирование прошло в соответствии с описанными в листинге~\ref{test-rules-java-n-python} пользовательскими правилами.
Кроме того, в этом можно убедиться выполнив запуск полученной программы (листинг~\ref{test-python-run}; обработанный текст был сохранен в файле <<test\_source\_instrumented.py>>; путь к рабочей директории опущен).

\begin{lstlisting}[frame=single, label={test-python-run}, caption={Результаты запуска обработанного тестового приложения.}]
~> python test_source_instrumented.py
INFO:simpleExample:before <if_statement> block in [Main] class, in {main} method
Hello World!
Hello World!
\end{lstlisting}

Однако можно заметить, что проверка на уникальность добавляемой зависимости от модуля <<logging>> прошла удачно, но не совсем некорректно, что вызвало появление альтернативной допустимой формы описания зависимостей (см. текст в строках 1 и 2 листинга~\ref{test-python-result}).
Это является следствием ограниченности созданной вручную аннотации грамматики и требует доработки.
Данная неточность была допущена специально для демонстрации важности знаний об особенностях целевого языка программирования, аннотацию грамматики которого требуется составить одному из пользователей разработанного генератора.

Из всего перечисленного выше можно сделать заключение об успешном решении поставленной тестовой задачи в рамках языка Python.

%%%%%%%%%%%%%%%%%%%
\subsubsection{Проект производственного уровня}
%%%%%%%%%%%%%%%%%%%

В соответствии с программой тестирования из кодовой базы проекта Keras был выбран файл <<keras/layers/convolutional.py>> в рамках тестирования разработанного прототипа.
Данный файл исходного текста содержит пример использования важной особенности языка Python -- описание нескольких классов в одном файле.

***

Для решения поставленной задачи было составлено правило инструментирования.
В листинге~\ref{test-rules-python} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка Python.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-python}, caption={Описание правил инструментирования. Python-проект.}]
...
context target_class:   { poi:class_name exists }
context target_method:  { poi:method_name = "__init__" }
context target_class_and_method:
  target_class & target_method

rules:
  print_usefull_message_to_the_log:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @target_class_and_method -> [first] method # before_body:
      make:  msg <- "In constructor of [" + $poi:class_name + "] class";
      add:   logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C++}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Для утилиты TXL существует грамматика, описывающая синтаксис языка C++, а именно, стандарта ANSI C++ 3.0~\cite{txl-resources}.
В соответствии с этой грамматикой была вручную написана аннотация для целей инструментирования основных синтетических конструкций.
Полный текст составленной аннотации в данной работе рассматриваться не будет.

Оценим работоспособность созданного прототипа генератора систем инструментирования в рамках языка C++ на примере приложений как тестового, так и промышленного уровня.

%%%%%%%%%%%%%%%%%%%
\subsubsection{Искуственный пример}
%%%%%%%%%%%%%%%%%%%

Одним из первых этапов приведенной выше программы тестирования является проведение инструментирования заранее подготовленного простого тестового приложения.
В листинге~\ref{test-c} приведен исходный текст синтетической тестовой программы для языка C++.

\begin{lstlisting}[frame=single, language=C, label={test-c}, caption={Исходный текст тестового приложения.}]
#include <iostream>
using namespace std;

class Main {
public:
  inline static int a = -10, b = -20;

  static void something_else() {
    if (a >= b) {
      if (a < 0)  cout << "Fizz Buzz!" << endl;
    }
    if (a >= b) {
      if (a < 0)  cout << "Fizz Buzz!" << endl;
    }
  }

  static void main();
};

void Main::main() {
  if (a >= b) {
    if (a < 0)  cout << "Hello World!" << endl;
  }
  if (a >= b) {
    if (a < 0)  cout << "Hello World!" << endl;
  }
}

int main() {
  Main::main();
}
\end{lstlisting}

Приведенный в листинге~\ref{test-python} текст программы во многом соответствует примеру для языка Java из листинга~\ref{test-java}.
Однако, явно заметно отличие, заключающееся в отделенном от тела класса описании реализации метода этого класса.
Вместе с тем в данном примере были использованы стандартные для языка C++ зависимости, соответствующие обозначенной ранее задаче.

Для синтетических тестовых примеров программ на языках С++ и Object Pascal было составлено общее описание правил инструментирования, полный текст которого приведен в листинге~\ref{test-rules-cpp-n-pascal} (форматирование изменено для компактности).

\begin{lstlisting}[frame=single, language=Python, label={test-rules-cpp-n-pascal}, caption={Описание правил инструментирования.}]
...
context namespace_m:  { poi:method_namespace matches "Main*" }
context method_m:     { poi:method_name matches "mai*" }
context class_and_method_m:  namespace_m & method_m

rules:
  print_usefull_message_to_the_log:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @@ -> [level] class("Main") # before_body:
      add:  logging_fields

    @class_and_method_m -> [first] method # before_body:
      add:  logging_init

    @class_and_method_m -> [all] method -> [first] if("*<* 0") # before:
      make:
        msg <- $std:pointcut + " <" + $std:node + "> block in [" + $poi:method_name_full + "] method";
      add:
        logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%%
\subsubsection{Проект производственного уровня}
%%%%%%%%%%%%%%%%%%%

В соответствии с программой тестирования из кодовой базы проекта Boost был выбран файл <<include/boost/uuid/detail/sha1.hpp>> в рамках тестирования разработанного прототипа.
Данный файл исходного текста соответствует возможностям используемой TXL-грамматики.
В процессе поиска файла для тестирования был выявлен факт слабой поддержки со стороны имеющейся грамматики возможностей препроцессора C++, что частично может быть решено выполнением инструментирования только файлов с исходным текстом, которые прошли этап пре-процессирования.

***

Для решения поставленной задачи было составлено правило инструментирования.
В листинге~\ref{test-rules-c} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка C++.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-c}, caption={Описание правил инструментирования. C++-проект.}]
...
context target_class:
  { poi:method_namespace matches "sha*" }

context target_method:
  { poi:method_name = "process_block" }

context target_class_and_method:
  target_class & target_method

rules:
  trace_processblock_func:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @@ -> [first] class("sha*") # before_body:
      add:  logging_fields

    @target_class_and_method -> [all] for # before:
      make:
        msg <- "<" + $std:pointcut + "> in [" + $poi:method_name_full + "] method";
      add:
        logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Object Pascal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Для утилиты TXL существует грамматика~\cite{txl-resources}, описывающая синтаксис языка Object Pascal, а именно, подмножества, использующегося средой быстрой разработки приложений Borland Delphi 2006.
В соответствии с этой грамматикой была вручную написана аннотация для целей инструментирования основных синтетических конструкций.
Фрагменты из этой аннотации были рассмотрены ранее.
Полный текст составленной аннотации в данной работе рассматриваться не будет.

Оценим работоспособность созданного прототипа генератора систем инструментирования в рамках языка Object Pascal на примере приложений как тестового, так и промышленного уровня.

%%%%%%%%%%%%%%%%%%%
\subsubsection{Искуственный пример}
%%%%%%%%%%%%%%%%%%%

***

В листинге~\ref{test-pascal} приведен исходный текст синтетической тестовой программы для языка Object Pascal.

\begin{lstlisting}[frame=single, language=Pascal, label={test-pascal}, caption={Исходный текст тестового приложения.}]
program test;
uses SysUtils;

type
  Main = class
  public
    a: integer;
    b: integer;
    procedure something_else(args: array of string);
    procedure main(args: array of string);
  end;

procedure Main.something_else(args: array of string);
begin
  if a >= b then
  begin
    if a < 0 then  System.writeln('Fizz Buzz!');
  end;
  if a >= b then
  begin
    if a < 0 then  System.writeln('Fizz Buzz!');
  end;
end;

procedure Main.main(args: array of string);
begin
  if a >= b then
  begin
    if a < 0 then  System.writeln('Hello World!');
  end;
  if a >= b then
  begin
    if a < 0 then  System.writeln('Hello World!');
  end;
end;

begin
  with Main.Create do
  begin
    a := -10;
    b := -20;
    main(['text']);
    Free;
  end;
end.
\end{lstlisting}

Приведенный в листинге~\ref{test-pascal} текст программы аналогичен примеру для языка C++ из листинга~\ref{test-c}.
Отличия заключаются в строго раздельном описании методов класса от тела этого класса вместе с невозможностью задания значений по-умолчанию для полей класса ввиду особенностей языка Object Pascal, и использовании модуля <<SysUtils>> в качестве стандартной зависимости в соответствии с задачей.
В данном примере не были использованы <<переменные~класса>> (аналог статических переменных) ввиду остутствия поддержки конструкции <<class~var>> со стороны имеющейся грамматики.

Как было указано ранее, для тестовых программ на языках Object Pascal и C++ использовался один и тот же файл с описание правил инструментирования.

***

%%%%%%%%%%%%%%%%%%%
\subsubsection{Проект производственного уровня}
%%%%%%%%%%%%%%%%%%%

В соответствии с программой тестирования из кодовой базы проекта Lazarus был выбран файл <<ide/compiler.pp>> в рамках тестирования разработанного прототипа.
Данный файл исходного текста содержит пример использования нескольких важных особенностей языка Object Pascal -- описание нескольких классов в одном файле и вложенные функции.
В процессе поиска файла для тестирования был выявлен факт слабой поддержки со стороны имеющейся грамматики возможностей препроцессора, что частично может быть решено выполнением инструментирования только файлов с исходным текстом, которые прошли этап пре-процессирования.

***

Для решения поставленной задачи было составлено правило инструментирования.
В листинге~\ref{test-rules-pascal} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка Object Pascal.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-pascal}, caption={Описание правил инструментирования. Object Pascal-проект.}]
...
context class:   { poi:method_namespace matches "TCompilerOpt*" }
context method:  { poi:method_name = "AddChoicesByOptOld" }
context class_and_method:  class & method

rules:
  trace_call_of_AddChoices:
    @@ -> [first] imports # all:
      add:  logging_dependencies
  
    @@ -> [level] class("TCompilerOpt") # before_body:
      add:  logging_fields

    @class_and_method -> [first] method("AddChoices") -> [first] if # before:
      make:
        msg <- "<" + $std:pointcut + "> in {AddChoices} of [" + $poi:method_name_full + "] method";
      add:
        logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Заключение}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***

Ниже перечислены возможные улучшения, собранные из наблюдения за работой прототипа и замеченных при проектировании и разработке принципов его работы:

\begin{itemize}[noitemsep]
  \item Подход к задаче инструментирования:
    \begin{itemize}[noitemsep]
        \item Применить <<нисходящий многопроходный>> метод обхода узлов дерева разбора.
        \item Разработать метод определения принадлежности узла контексту инструментирования в условиях частичного отсутствия информации.
        \item Реализовать возможность описания зависимых пользовательских правил инструментирования.
        \item Разработать методику обработки различных форм представлений отдельно взятого ключевого понятия целевого языка программирования.
        \item Рассмотреть возможность перехода к задаче трансформации кода через добавление и планирование операций обновления и удаления узлов дерева разбора.
    \end{itemize}

  \item Реализация прототипа генератора систем инструментирования:
    \begin{itemize}[noitemsep]
      \item Разработать более гибкий подход к формированию новых разновидностей синтезируемых TXL функций (подобных R-, G-, W-функциям и т.д.).
      \item Использовать встроенный парсер языка TXL и описания пользовательских правил (например, на основе ANTLR~\cite{antlr}).
      \item Реализовать автоматический сбор подходящих узлов дерева разбора, основываясь на создаваемых пользователем <<переменных>>, а именно -- используемых при этом <<точек интереса>> (POI).
      \item Перенести КНФ решатель/преобразователь в C++ код.
      \item Расширить множество доступных типов переменных, определяемых пользователем.
      \item Реализовать описание и использование (in-place) текста врагмента одновременно для конкретной точки инструментирования.
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выводы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе был рассмотрен процесс и результаты тестирования разработанного прототипа генератора систем автоматизации инструментирования программ.
Были проведены эксперименты как с заранее приготовленными синтетическими данными (специально подобранные упрощенные тексты программ, главная цель которых заключается в проведении оценки работоспособности разработанного метода инструментрования вместе с отладкой аннотации грамматики целевого языка программирования), так и с текстами из кодовых баз различных программных продуктов промышленного уровня.
Полученные результаты показали ограниченную работоспособность выбранного подхода и инструмента.
Были приведены замеченные в ходе тестирования недостатки и ограничения как прототипа, так и выбранного подхода, а также в заключении рассмотрены возможные способы дальнейшего развития данного прототипа.
