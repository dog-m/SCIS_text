%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Тестирование генератора систем инструментирования и анализ результатов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе производится тестирование разработанного прототипа генератора систем автоматизации инструментирования программ и оценка примененных подходов.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Методика испытаний}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Методика испытаний разработанного прототипа генератора систем инструментирования заключается в ручном составлении пользовательских правил инструментирования и последующем применении этих правил к файлу, содержащему текст некоторой программы (целиком или только отдельная часть) при помощи разработанного прототипа (генератора систем инструментирования) с последующим анализом полученного инструментированного текста программы.
Текст программы перед проведением тестирования подвергается процедуре нормализации без внесения изменений вручную (как предоставляется разработчиком).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Программа испытаний}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***

Программа испытаний разработанного прототипа заключается в выполнении следующей последовательности операций:

\begin{enumerate}[label=\arabic*]
  \item Выполняется выбор целевых языков программирования.
  \item В соответствии с выбранным набором ЯП производится поиск и подбор проектов с открытым исходым кодом и лицензией, позволяющей вносить изменения лицам, не являющимся членами группы разработки или компании-разработчика.
  \item Для каждого выбранного языка программирования:
    \begin{enumerate}[label*=.\arabic*]
      \item составление библиотеки добавляемых в исходный текст программы фрагментов -- несколько взаимосвязных фрагментов;

      \item поиск существующей грамматики языка;
      \item составление аннотации к выбранной грамматике;
      \item отладка аннотации и грамматики;

      \item ручное написание синтетического тестового исходного кода;
      \item выбор фрагментов исходных текстов из подобранных ранее проектов с открытым исходным кодом с учетом поддержки возможностей ЯП со стороны имеющейся грамматики;
      \item выполнение нормализации исходных текстов при помощи грамматики выбранного языка и утилиты TXL;

      \item осуществляется постановка тестовых задач;
      \item составление пользовательских правил инструментирования для решения поставленной задачи;

      \item выполнение инструментирования при помощи разработанного прототипа;
      \item анализ полученного инструментированного текста программы на соответствие описанным ожиданиям, описанных в виде пользовательских правил инструментирования.
    \end{enumerate}

  \item Общий анализ полученных результатов и оценка возможностей по усовершенствованию разработанного прототипа.
\end{enumerate}

***

%%%%%%%%%%%%%%%%%%
\subsection{Языки программирования}
%%%%%%%%%%%%%%%%%%

***

В данной работе было выполнено инструментирование фрагментов исходных текстов нескольких программ, созданных с использованием различных языков программирования общего назначения с разной степенью поддержки структурного программирования.

Для утилиты TXL опубликованы описания грамматик некоторых языков программирования общего назначения, такие как \cite{txl-resources}:
\begin{multicols}{2}
\begin{itemize}[noitemsep]
  \item TXL
  \item PHP
  \item JavaScript
  \item Ada
  \item ATL
  \item Ada
  \item C\#
  \item Eiffel
  \item Fortran
  \item Modula 3
  \item Ruby
  \item VisualBasic

  \item Java
  \item Python
  \item Object Pascal
  \item С++
\end{itemize}
\end{multicols}

Поскольку некоторые языки обладают схожей степенью строгости применительно к структурному программированию, например: C\# и Java, С++ и PHP, VisualBasic и Object Pascal, были рассмотрены программы на следующих языках программирования:
\begin{itemize}[noitemsep]
  \item Java
  \item Python
  \item Object Pascal
  \item С++
\end{itemize}

В список были ключены языки Python и Object Pascal по причине применения отличного от <<C-подобного>> стиля оформления блоков кода: Python -- отступы, Object Pascal -- специальные ключевые слова <<begin>> и <<end>>.

***

%%%%%%%%%%%%%%%%%%
\subsection{Проекты с открытым исходным кодом}
%%%%%%%%%%%%%%%%%%

***

Для проведения тестирования были выбраны следующие проекты с открытым исходным кодом:

\begin{itemize}[noitemsep]
  \item AspectJ       \cite{aspectj} --
  система и DSL, предназначенные для реализации принципов аспектно-ориентированного программирования в рамках языка программирования Java.

  \item Keras library \cite{keras} --
  библиотека для высокоуровневой обработки и построения моделей глубокого обучения для языка Python.

  \item Lazarus IDE   \cite{lazarus} --
  графическая среда быстрой разработки приложений на языке программирования Object Pascal и близких его диалектах.

  \item Boost library \cite{boost} --
  многофункциональная модульная библиотека для применения при построении программных продуктов с использованием языка программирования C++.
\end{itemize}
\nomenclature{IDE}{Integrated Development Environment -- интегрированная среда разработки.}

***

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Протокол испытаний}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В соответствии с рассмотренной выше программой и методикой испытаний было выполнено тестирование разработанного прототипа генератора систем инструментирования исходного текста программ.
Далее приведены тестовые данные вместе с полученными результатами.

***

В данном разделе будут рассмотрены исходные тексты программ, использованных при тестировании прототипа.
Тестирование было проведено как с заранее приготовленными синтетическими данными (специально подобранные упрощенные тексты программ, главная цель которых заключается в проведении оценки работоспособности разработанного метода инструментрования вместе с отладкой аннотации грамматики целевого языка программирования), так и с текстами из кодовых баз различных программных продуктов промышленного уровня.

***

%%%%%%%%%%%%%%%%%%
\subsection{C++}
%%%%%%%%%%%%%%%%%%

***

Для утилиты TXL существует грамматика, описывающая синтаксис языка C++, а именно, стандарта ANSI C++ 3.0.

***

В листинге~\ref{test-c} приведен исходный текст синтетической тестовой программы для языка C++.

\begin{lstlisting}[frame=single, language=C, label={test-c}, caption={Исходный текст тестового приложения.}]
#include <iostream>
using namespace std;

class Main {
  int a = 10, b = 20;

  static void something_else() {
    if (a >= b) {
      if (a < 0)
        cout << "Fizz Buzz!" << endl;
    }
    if (a >= b) {
      if (a < 0)
        cout << "Fizz Buzz!" << endl;
    }
  }

  static void main();
};

void Main::main() {
  if (a >= b) {
    if (a < 0)
      cout << "Hello World!" << endl;
  }
  if (a >= b) {
    if (a < 0)
      cout << "Hello World!" << endl;
  }
}

int main() {
  Main::main();
}
\end{lstlisting}

***

В листинге~\ref{test-rules-c} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка C++.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-c}, caption={Описание правил инструментирования. C++-проект.}]
use fragment "logging/dependencies"
use fragment "logging/fields"
use fragment "logging/message"

context target_class:
  { poi:method_namespace matches "sha*" }

context target_method:
  { poi:method_name = "process_block" }

context target_class_and_method:
  target_class & target_method

rules:
  trace_processblock_func:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @@ -> [first] class("sha*") # before_body:
      add:  logging_fields

    @target_class_and_method -> [all] for # before:
      make:
        msg <- "<" + $std:pointcut + "> in [" + $poi:method_name_full + "] method";
      add:
        logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%
\subsection{Object Pascal}
%%%%%%%%%%%%%%%%%%

***

Для утилиты TXL существует грамматика, описывающая синтаксис языка Object Pascal, а именно, подмножества, использующегося средой быстрой разработки приложений Borland Delphi 2006.

***

В листинге~\ref{test-pascal} приведен исходный текст синтетической тестовой программы для языка Object Pascal.

\begin{lstlisting}[frame=single, language=Pascal, label={test-pascal}, caption={Исходный текст тестового приложения.}]
program test;

uses SysUtils;

type
  Main = class
  public
    a: integer;
    b: integer;
    procedure something_else(args: array of string);
    procedure main(args: array of string);
  end;

procedure Main.something_else(args: array of string);
begin
  if a >= b then
  begin
    if a < 0 then
      System.writeln('Fizz Buzz!');
  end;
  if a >= b then
  begin
    if a < 0 then
      System.writeln('Fizz Buzz!');
  end;
end;

procedure Main.main(args: array of string);
begin
  if a >= b then
  begin
    if a < 0 then
      System.writeln('Hello World!');
  end;
  if a >= b then
  begin
    if a < 0 then
      System.writeln('Hello World!');
  end;
end;

begin
  with Main.Create do
  begin
    a := 10;
    b := 20;
    main(['text']);
    Free;
  end;
end.
\end{lstlisting}

***

В листинге~\ref{test-rules-pascal} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка Object Pascal.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-pascal}, caption={Описание правил инструментирования. Object Pascal-проект.}]
...
context class:   { poi:method_namespace matches "TCompilerOpt*" }
context method:  { poi:method_name = "AddChoicesByOptOld" }
context class_and_method:  class & method

rules:
  trace_call_of_AddChoices:
    @@ -> [first] imports # all:
      add:  logging_dependencies
  
    @@ -> [level] class("TCompilerOpt") # before_body:
      add:  logging_fields

    @class_and_method -> [first] method("AddChoices") -> [first] if # before:
      make:
        msg <- "<" + $std:pointcut + "> in {AddChoices} of [" + $poi:method_name_full + "] method";
      add:
        logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%
\subsection{Java}
%%%%%%%%%%%%%%%%%%

***

Для утилиты TXL существует грамматика, описывающая синтаксис языка Java версии 8.

***

В листинге~\ref{test-java} приведен исходный текст синтетической тестовой программы для языка Java.

\begin{lstlisting}[frame=single, language=Java, label={test-java}, caption={Исходный текст тестового приложения.}]
package com.test;

import java.util.logging.Level;
import java.util.logging.ConsoleHandler;

public class Main {
  public static int a = 10;
  public static int b = 20;

  public static void something_else(String[] args) {
    if (a >= b) {
      if (a < 0)
        System.out.println("Fizz Buzz!");
    }
    if (a >= b) {
      if (a < 0)
        System.out.println("Fizz Buzz!");
    }
  }

  public static void main(String[] args) {
    if (a >= b) {
      if (a < 0)
        System.out.println("Hello World!");
    }
    if (a >= b) {
      if (a < 0)
        System.out.println("Hello World!");
    }
  }
}
\end{lstlisting}

***

В листинге~\ref{test-rules-java} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка Java.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-java}, caption={Описание правил инструментирования. Java-проект.}]
...
context target_class:  { poi:class_name = "AsmManager" }

rules:
  trace_while_loops_in_Model:
    @@ -> [first] imports # all:
      add:  logging_dependencies
  
    @target_class -> [first] class("Model*") # before_body:
      add:  logging_fields
  
    @target_class -> [first] class("Model*") -> [all] while # before:
      make:  msg <- $std:pointcut + " " + $std:node;
      add:   logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%
\subsection{Python}
%%%%%%%%%%%%%%%%%%

***

Для утилиты TXL существует грамматика, описывающая синтаксис языка Python версии 2.5 и некоторые элементы из 3.0.

***

В листинге~\ref{test-python} приведен исходный текст синтетической тестовой программы для языка Python.

\begin{lstlisting}[frame=single, language=Python, label={test-python}, caption={Исходный текст тестового приложения.}]
from logging import *

class Main:
    def __init__(self):
        self.a = 10
        self.b = 20

    def something_else(self, args):
        if self.a >= self.b:
          if a < 0:
            print "Fizz Buzz!"
        if a >= b:
          if a < 0:
            print "Fizz Buzz!"

    def main(self, args):
        if self.a >= self.b:
          if self.a < 0:
            print "Hello World!"
        if self.a >= self.b:
          if self.a < 0:
            print "Hello World!"

Main().main({})
\end{lstlisting}

***

В листинге~\ref{test-rules-python} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка Python.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-python}, caption={Описание правил инструментирования. Python-проект.}]
...
context target_class:   { poi:class_name exists }
context target_method:  { poi:method_name = "__init__" }
context target_class_and_method:
  target_class & target_method

rules:
  print_usefull_message_to_the_log:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @target_class_and_method -> [first] method # before_body:
      make:  msg <- "In constructor of [" + $poi:class_name + "] class";
      add:   logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%
\subsection{Развитие прототипа}
%%%%%%%%%%%%%%%%%%

Ниже перечислены возможные улучшения, собранные из наблюдения за работой прототипа и замеченных при проектировании и разработке принципов его работы:

\begin{itemize}[noitemsep]
  \item Подход к задаче инструментирования:
    \begin{itemize}[noitemsep]
        \item Применить <<нисходящий многопроходный>> метод обхода узлов дерева разбора.
        \item Разработать метод определения принадлежности узла контексту инструментирования в условиях частичного отсутствия информации.
        \item Реализовать возможность описания зависимых пользовательских правил инструментирования.
        \item Разработать методику обработки различных форм представлений отдельно взятого ключевого понятия целевого языка программирования.
        \item Рассмотреть возможность перехода к задаче трансформации кода через добавление и планирование операций обновления и удаления узлов дерева разбора.
    \end{itemize}

  \item Реализация прототипа генератора систем инструментирования:
    \begin{itemize}[noitemsep]
      \item Разработать более гибкий подход к формированию новых разновидностей синтезируемых TXL функций (подобных R-, G-, W-функциям и т.д.).
      \item Использовать встроенный парсер языка TXL и описания пользовательских правил (например, на основе ANTLR~\cite{antlr}).
      \item Реализовать автоматический сбор подходящих узлов дерева разбора, основываясь на создаваемых пользователем <<переменных>>, а именно -- используемых при этом <<точек интереса>> (POI).
      \item Перенести КНФ решатель/преобразователь в C++ код.
      \item Расширить множество доступных типов переменных, определяемых пользователем.
      \item Реализовать описание и использование (in-place) текста врагмента одновременно для конкретной точки инструментирования.
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выводы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе был рассмотрен процесс и результаты тестирования разработанного прототипа генератора систем автоматизации инструментирования программ.
***
Проведенные эксперименты на реальных и синтетических данных (исходных текстах программ) показали работоспособность подхода и инструмента.
Были приведены замеченные в ходе тестирования недостатки и ограничения как прототипа, так и выбранного подхода, а также рассмотрены возможные способы дальнейшего развития данного прототипа.

