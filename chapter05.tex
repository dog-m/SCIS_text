%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Тестирование генератора систем инструментирования и анализ результатов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе производится тестирование разработанного прототипа генератора систем автоматизации инструментирования программ и оценка примененных подходов.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Методика испытаний}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Методика испытаний разработанного прототипа генератора систем инструментирования заключается в ручном составлении пользовательских правил инструментирования и последующем применении этих правил к файлу, содержащему текст некоторой программы (целиком или только отдельная часть) при помощи разработанного прототипа (генератора систем инструментирования) с последующим анализом полученного инструментированного текста программы.
Текст программы перед проведением тестирования подвергается процедуре нормализации без внесения изменений вручную (как предоставляется разработчиком).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Программа испытаний}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***

Программа испытаний разработанного прототипа заключается в выполнении следующей последовательности операций:

\begin{enumerate}[label=\arabic*]
  \item Выполняется выбор целевых языков программирования.
  \item В соответствии с выбранным набором ЯП производится поиск и подбор проектов с открытым исходым кодом и лицензией, позволяющей вносить изменения лицам, не являющимся членами группы разработки или компании-разработчика.
  \item Для каждого выбранного языка программирования:
    \begin{enumerate}[label*=.\arabic*]
      \item составление библиотеки добавляемых в исходный текст программы фрагментов -- несколько взаимосвязных фрагментов;

      \item поиск существующей грамматики языка;
      \item составление аннотации к выбранной грамматике;
      \item отладка аннотации и грамматики;

      \item ручное написание синтетического тестового исходного кода;
      \item выбор фрагментов исходных текстов из подобранных ранее проектов с открытым исходным кодом с учетом поддержки возможностей ЯП со стороны имеющейся грамматики;
      \item выполнение нормализации исходных текстов при помощи грамматики выбранного языка и утилиты TXL;

      \item осуществляется постановка тестовых задач;
      \item составление пользовательских правил инструментирования для решения поставленной задачи;

      \item выполнение инструментирования при помощи разработанного прототипа;
      \item анализ полученного инструментированного текста программы на соответствие описанным ожиданиям, описанных в виде пользовательских правил инструментирования.
    \end{enumerate}

  \item Общий анализ полученных результатов и оценка возможностей по усовершенствованию разработанного прототипа.
\end{enumerate}

Поиск и оценка изменений выполнялись как визуально, так и с помощью программных средств, таких как консольная <<diffutils>>~\cite{git} и графическая <<TortoiseGitMerge>>~\cite{tortoise-git} утилиты.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Языки программирования}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данной работе было выполнено инструментирование фрагментов исходных текстов нескольких программ, созданных с использованием различных языков программирования общего назначения с разной степенью поддержки структурного программирования.

Для утилиты TXL опубликованы описания грамматик некоторых языков программирования общего назначения, такие как~\cite{txl-resources}:
\begin{multicols}{2}
\begin{itemize}[noitemsep]
  \item TXL
  \item PHP
  \item JavaScript
  \item Ada
  \item ATL
  \item Ada
  \item C\#
  \item Eiffel
  \item Fortran
  \item Modula 3
  \item Ruby
  \item VisualBasic

  \item Java
  \item Python
  \item Object Pascal
  \item С++
\end{itemize}
\end{multicols}

Поскольку некоторые языки обладают схожей степенью строгости применительно к структурному программированию, например: C\# и Java, С++ и PHP, VisualBasic и Object Pascal.
Ниже представлен список рассмотренных ЯП вместе с ключевыми особенностями, по которым был выбран тот или иной язык программирования.

\begin{itemize}[noitemsep]
  \item Java:
    \begin{itemize}[noitemsep]
      \item C-подобный стиль оформления блоков кода (использование символов <<\{>> и <<\}>>);
      \item сильное влияние структурной парадигмы программирования (<<класс>> вложен в <<пакет>>, <<метод>> вложен в <<класс>>);
      \item наличие вложенных структур одного вида (<<класс>> вложен в <<класс>>);
      \item запрет описания функций вне тела класса;
      \item название имени файла совпадает с именем описываемого класса;
      \item запрет на повторное включение зависимостей;
    \end{itemize}

  \item Python:
    \begin{itemize}[noitemsep]
      \item применение различных уровней отступов (символ <<побел>> или <<табуляция>>);
      \item влияние структурной парадигмы программирования (методы описываются в теле классов);
      \item запрет использования блоков кода, оформенных отступами, в середине другого блока кода
      \item различные варианты описания конструкции импорта зависимостей;
    \end{itemize}

  \item Object Pascal:
    \begin{itemize}[noitemsep]
      \item использование специальных ключевых слов <<begin>> и <<end>> для оформления блоков кода;
      \item применение директив препроцессора;
      \item наличие вложенных структур одного вида (<<функция>> вложена в <<функцию>>);
      \item наличие вложенных структур разного вида (<<класс>> вложен в <<функцию>>);
      \item опциональное использование символа <<;>> после инструкции или блока кода в зависимости от наличия или отсутствия ветки <<else>> конструкции ветвления;
      \item слабое влияние структурной парадигмы программирования (методы класса описываются отдельно от тела самого класса);
      \item вставка кода на другом языке программирования (различные диалекты языка ассемблера);
      \item запрет на повторное включение зависимостей;
    \end{itemize}

  \item С++:
    \begin{itemize}[noitemsep]
      \item C-подобный стиль оформления блоков кода;
      \item применение директив препроцессора;
      \item наличие вложенных структур одного вида (<<класс>> вложен в <<класс>>);
      \item наличие вложенных структур разного вида (<<класс>> вложен в <<функцию>>);
      \item относительно (языка Java) слабое влияние структурной парадигмы программирования (методы класса обычно описываются отдельно от тела самого класса);
      \item вставка кода на другом языке программирования (различные диалекты языка ассемблера);
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Проекты с открытым исходным кодом}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***

В данном разделе будут рассмотрены исходные тексты программ, использованных при тестировании прототипа.
Тестирование было проведено как с заранее приготовленными синтетическими данными (специально подобранные упрощенные тексты программ, главная цель которых заключается в проведении оценки работоспособности разработанного метода инструментрования вместе с отладкой аннотации грамматики целевого языка программирования), так и с текстами из кодовых баз различных программных продуктов промышленного уровня.

***

Для проведения тестирования были выбраны следующие проекты с открытым исходным кодом:

\begin{itemize}[noitemsep]
  \item AspectJ       \cite{aspectj} --
  система и DSL, предназначенные для реализации принципов аспектно-ориентированного программирования в рамках языка программирования Java.

  \item Keras library \cite{keras} --
  библиотека-надстройка для высокоуровневой обработки и построения нейосетевых моделей глубинного обучения для языка Python.

  \item Lazarus IDE   \cite{lazarus} --
  графическая кросплатформенная среда быстрой разработки приложений на языке программирования Object Pascal и близких его диалектах.

  \item Boost library \cite{boost} --
  многофункциональная модульная библиотека для применения при построении программных продуктов с использованием языка программирования C++.
\end{itemize}
\nomenclature{IDE}{Integrated Development Environment -- интегрированная среда разработки.}

***

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Протокол испытаний}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В соответствии с рассмотренной выше программой и методикой испытаний было выполнено тестирование разработанного прототипа генератора систем инструментирования исходного текста программ.
В данной работе не будут рассмотрены тексты созданных аннотаций к представленным в~\cite{txl-resources} грамматикам.
Важно заранее отметить, что некоторые элементы грамматик были незначительно изменены для большего соответствия используемому в разработанном прототипе подходу к задаче инструментирования.
Далее будут приведены тестовые данные вместе с полученными результатами для каждого из выбранных ранее языков программирования.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Java}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***

Для утилиты TXL существует корректная грамматика~\cite{txl-resources}, описывающая синтаксис языка Java версии 8.

***

%%%%%%%%%%%%%%%%%%%
\subsubsection{Искуственный пример}
%%%%%%%%%%%%%%%%%%%

***

В листинге~\ref{test-java} приведен исходный текст синтетической тестовой программы для языка Java.

\begin{lstlisting}[frame=single, language=Java, label={test-java}, caption={Исходный текст тестового приложения.}]
package com.test;
import java.util.logging.Level;
import java.util.logging.ConsoleHandler;

public class Main {
  public static int a = 20;
  public static int b = 10;

  public static void something_else(String[] args) {
    if (a >= b) {
      if (a < 0)  System.out.println("Fizz Buzz!");
    }
    if (a >= b) {
      if (a < 0)  System.out.println("Fizz Buzz!");
    }
  }

  public static void main(String[] args) {
    if (a >= b) {
      if (a < 0)  System.out.println("Hello World!");
    }
    if (a >= b) {
      if (a < 0)  System.out.println("Hello World!");
    }
  }
}
\end{lstlisting}

В приведенном тексте программы производится объявление класса с именем <<Main>>, который содержит статические методы с именами <<main>> и <<something\_else>>.
Помимо этого в теле класса представлены целочисленные поля с именами <<a>> и <<b>>.
Каждый объявленный метод содержит несколько вложенных конструкций ветвления <<if>> вместе с несколькими вызовами стандартной функции вывода строки текста в консоль.

Для синтетических тестовых примеров программ на языках Java и Python было составлено общее описание правил инструментирования, полный текст которого приведен в листинге~\ref{test-rules-java-n-python} (форматирование изменено для компактности).
Аналогично были составлены правила для C++ и Object Pascal, которые будут рассмотрены далее.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-java-n-python}, caption={Описание правил инструментирования.}]
use fragment "logging/dependencies"
use fragment "logging/fields"
use fragment "logging/init"
use fragment "logging/message"

context class_m:   { poi:class_name = "Main" }
context method_m:  { poi:method_name matches "mai*" }
context class_and_method_m:  class_m & method_m

rules:
  print_usefull_message_to_the_log:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @class_m -> [first] class # before_body:
      add:  logging_fields

    @class_and_method_m -> [first] method # before_body:
      add:  logging_init

    @class_and_method_m -> [first] if # before:
      make:
        msg <- $std:pointcut + " <" + $std:node + "> block in [" + $poi:class_name + "] class, in {" + $poi:method_name + "} method";
      add:
        logging_message(msg)
\end{lstlisting}

В листинге~\ref{test-java-result} приведен программный код обработанной тестовой программы на языке Java, которая прошла операцию инструментирования при помощи разработанного прототипа генератора систем инструментирования (форматирование изменено для компактности; знак <<+>> в начале строки обозначает строку, которая была добавлена).

\begin{lstlisting}[frame=single, language=Java, label={test-java-result}, caption={Текст инструментированного тестового приложения.}]
package com.test;
import java.util.logging.Level;
import java.util.logging.ConsoleHandler;
+ import java.util.logging.Logger;
+ import java.util.logging.Handler;

public class Main {
+ private static final Logger iLogger = Logger.getLogger(getClass().getName());
+ private static final Handler iHandler = newConsoleHandler();
  public static int a = 20;
  public static int b = 10;

  public static void something_else (String [] args) {
    if (a >= b) {
      if (a < 0)  System.out.println ("Fizz Buzz!");
    }
    if (a >= b) {
      if (a < 0)  System.out.println ("Fizz Buzz!");
    }
  }

  public static void main (String [] args) {
+   iHandler.setLevel (Level.ALL);
+   iLogger.addHandler (iHandler);
+   iLogger.setLevel (Level.ALL);
+   {
+     {
+       iLogger.log(Level.FINE, "before <if_statement> block in [Main] class, in {main} method");
        if (a >= b) {
          if (a < 0)  System.out.println ("Hello World!");
        }
+     }
      if (a >= b) {
        if (a < 0)  System.out.println ("Hello World!");
      }
+   }
  }
}
\end{lstlisting}

Из полученного текста программы можно сделать вывод, что инструментирование прошло в точном соответствии с описанными в листинге~\ref{test-rules-java-n-python} пользовательскими правилами.
Отсюда можно сделать заключение об успешном решении поставленной тестовой задачи в рамках языка Java.

%%%%%%%%%%%%%%%%%%%
\subsubsection{Проект производственного уровня}
%%%%%%%%%%%%%%%%%%%

***

В листинге~\ref{test-rules-java} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка Java.
Здесь и далее используемые фрагменты совпадают с описанными ранее тестовым примером~\ref{test-rules-java-n-python} и содержат только фрагменты <<logging/dependencies>>, <<logging/fields>>, <<logging/init>> и <<logging/message>>.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-java}, caption={Описание правил инструментирования. Java-проект.}]
...
context target_class:  { poi:class_name = "AsmManager" }

rules:
  trace_while_loops_in_Model:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @target_class -> [first] class("Model*") # before_body:
      add:  logging_fields

    @target_class -> [first] class("Model*") -> [all] while # before:
      make:  msg <- $std:pointcut + " " + $std:node;
      add:   logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Python}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***

Для утилиты TXL существует грамматика~\cite{txl-resources}, описывающая синтаксис языка Python версии 2.5 и некоторые элементы из 3.0.

***

%%%%%%%%%%%%%%%%%%%
\subsubsection{Искуственный пример}
%%%%%%%%%%%%%%%%%%%

***

В листинге~\ref{test-python} приведен исходный текст синтетической тестовой программы для языка Python.

\begin{lstlisting}[frame=single, language=Python, label={test-python}, caption={Исходный текст тестового приложения.}]
from logging import *   # alternative form

class Main:
    def __init__(self):
        self.a = 20
        self.b = 10

    def something_else(self, args):
        if self.a >= self.b:
          if a < 0:
            print "Fizz Buzz!"
        if a >= b:
          if a < 0:
            print "Fizz Buzz!"

    def main(self, args):
        if self.a >= self.b:
          if self.a < 0:
            print "Hello World!"
        if self.a >= self.b:
          if self.a < 0:
            print "Hello World!"

Main().main({})
\end{lstlisting}

Приведенный в листинге~\ref{test-python} текст программы аналогичен примеру для языка Java из листинга~\ref{test-java}.
Отличия заключаются в отсутствии определения полей и статических методов класса ввиду особенностей языка Python, и использовании соответствующего набора стандартных зависимостей в соответствии с задачей.

Как было указано ранее, для тестовых программ на языках Python и Java использовался один и тот же файл с описание правил инструментирования.

***

%%%%%%%%%%%%%%%%%%%
\subsubsection{Проект производственного уровня}
%%%%%%%%%%%%%%%%%%%

***

В листинге~\ref{test-rules-python} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка Python.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-python}, caption={Описание правил инструментирования. Python-проект.}]
...
context target_class:   { poi:class_name exists }
context target_method:  { poi:method_name = "__init__" }
context target_class_and_method:
  target_class & target_method

rules:
  print_usefull_message_to_the_log:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @target_class_and_method -> [first] method # before_body:
      make:  msg <- "In constructor of [" + $poi:class_name + "] class";
      add:   logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C++}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***

Для утилиты TXL существует грамматика~\cite{txl-resources}, описывающая синтаксис языка C++, а именно, стандарта ANSI C++ 3.0.

***

%%%%%%%%%%%%%%%%%%%
\subsubsection{Искуственный пример}
%%%%%%%%%%%%%%%%%%%

***

В листинге~\ref{test-c} приведен исходный текст синтетической тестовой программы для языка C++.

\begin{lstlisting}[frame=single, language=C, label={test-c}, caption={Исходный текст тестового приложения.}]
#include <iostream>
using namespace std;

class Main {
  int a = 20, b = 10;

  static void something_else() {
    if (a >= b) {
      if (a < 0)  cout << "Fizz Buzz!" << endl;
    }
    if (a >= b) {
      if (a < 0)  cout << "Fizz Buzz!" << endl;
    }
  }

  static void main();
};

void Main::main() {
  if (a >= b) {
    if (a < 0)  cout << "Hello World!" << endl;
  }
  if (a >= b) {
    if (a < 0)  cout << "Hello World!" << endl;
  }
}

int main() {
  Main::main();
}
\end{lstlisting}

Приведенный в листинге~\ref{test-python} текст программы во многом соответствует примеру для языка Java из листинга~\ref{test-java}.
Однако, явно заметно отличие, заключающееся в отделенном от тела класса описании реализации метода этого класса.
Вместе с тем в данном примере были использованы стандартные для языка C++ зависимости, соответствующие обозначенной ранее задаче.

Для синтетических тестовых примеров программ на языках С++ и Object Pascal было составлено общее описание правил инструментирования, полный текст которого приведен в листинге~\ref{cpp-n-pascal} (форматирование изменено для компактности).

\begin{lstlisting}[frame=single, language=Python, label={test-rules-cpp-n-pascal}, caption={Описание правил инструментирования.}]
...
context namespace_m:  { poi:method_namespace matches "Main*" }
context method_m:     { poi:method_name matches "mai*" }
context class_and_method_m:  namespace_m & method_m

rules:
  print_usefull_message_to_the_log:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @@ -> [level] class("Main") # before_body:
      add:  logging_fields

    @class_and_method_m -> [first] method # before_body:
      add:  logging_init

    @class_and_method_m -> [all] method -> [first] if("*<* 0") # before:
      make:
        msg <- $std:pointcut + " <" + $std:node + "> block in [" + $poi:method_name_full + "] method";
      add:
        logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%%
\subsubsection{Проект производственного уровня}
%%%%%%%%%%%%%%%%%%%

***

В листинге~\ref{test-rules-c} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка C++.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-c}, caption={Описание правил инструментирования. C++-проект.}]
...
context target_class:
  { poi:method_namespace matches "sha*" }

context target_method:
  { poi:method_name = "process_block" }

context target_class_and_method:
  target_class & target_method

rules:
  trace_processblock_func:
    @@ -> [first] imports # all:
      add:  logging_dependencies

    @@ -> [first] class("sha*") # before_body:
      add:  logging_fields

    @target_class_and_method -> [all] for # before:
      make:
        msg <- "<" + $std:pointcut + "> in [" + $poi:method_name_full + "] method";
      add:
        logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Object Pascal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***

Для утилиты TXL существует грамматика~\cite{txl-resources}, описывающая синтаксис языка Object Pascal, а именно, подмножества, использующегося средой быстрой разработки приложений Borland Delphi 2006.

***

%%%%%%%%%%%%%%%%%%%
\subsubsection{Искуственный пример}
%%%%%%%%%%%%%%%%%%%

***

В листинге~\ref{test-pascal} приведен исходный текст синтетической тестовой программы для языка Object Pascal.

\begin{lstlisting}[frame=single, language=Pascal, label={test-pascal}, caption={Исходный текст тестового приложения.}]
program test;
uses SysUtils;

type
  Main = class
  public
    a: integer;
    b: integer;
    procedure something_else(args: array of string);
    procedure main(args: array of string);
  end;

procedure Main.something_else(args: array of string);
begin
  if a >= b then
  begin
    if a < 0 then  System.writeln('Fizz Buzz!');
  end;
  if a >= b then
  begin
    if a < 0 then  System.writeln('Fizz Buzz!');
  end;
end;

procedure Main.main(args: array of string);
begin
  if a >= b then
  begin
    if a < 0 then  System.writeln('Hello World!');
  end;
  if a >= b then
  begin
    if a < 0 then  System.writeln('Hello World!');
  end;
end;

begin
  with Main.Create do
  begin
    a := 20;
    b := 10;
    main(['text']);
    Free;
  end;
end.
\end{lstlisting}

Приведенный в листинге~\ref{test-pascal} текст программы аналогичен примеру для языка C++ из листинга~\ref{test-c}.
Отличия заключаются в строго раздельном описании методов класса от тела этого класса вместе с невозможностью задания значений по-умолчанию для полей класса ввиду особенностей языка Object Pascal, и использовании модуля <<SysUtils>> в качестве стандартной зависимости в соответствии с задачей.

Как было указано ранее, для тестовых программ на языках Object Pascal и C++ использовался один и тот же файл с описание правил инструментирования.

***

%%%%%%%%%%%%%%%%%%%
\subsubsection{Проект производственного уровня}
%%%%%%%%%%%%%%%%%%%

***

В листинге~\ref{test-rules-pascal} приведен текст описания правил инструментирования для обработки файла с исходным текстом проекта, созданного с использованием языка Object Pascal.

\begin{lstlisting}[frame=single, language=Python, label={test-rules-pascal}, caption={Описание правил инструментирования. Object Pascal-проект.}]
...
context class:   { poi:method_namespace matches "TCompilerOpt*" }
context method:  { poi:method_name = "AddChoicesByOptOld" }
context class_and_method:  class & method

rules:
  trace_call_of_AddChoices:
    @@ -> [first] imports # all:
      add:  logging_dependencies
  
    @@ -> [level] class("TCompilerOpt") # before_body:
      add:  logging_fields

    @class_and_method -> [first] method("AddChoices") -> [first] if # before:
      make:
        msg <- "<" + $std:pointcut + "> in {AddChoices} of [" + $poi:method_name_full + "] method";
      add:
        logging_message(msg)
\end{lstlisting}

***

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Заключение}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

***

Ниже перечислены возможные улучшения, собранные из наблюдения за работой прототипа и замеченных при проектировании и разработке принципов его работы:

\begin{itemize}[noitemsep]
  \item Подход к задаче инструментирования:
    \begin{itemize}[noitemsep]
        \item Применить <<нисходящий многопроходный>> метод обхода узлов дерева разбора.
        \item Разработать метод определения принадлежности узла контексту инструментирования в условиях частичного отсутствия информации.
        \item Реализовать возможность описания зависимых пользовательских правил инструментирования.
        \item Разработать методику обработки различных форм представлений отдельно взятого ключевого понятия целевого языка программирования.
        \item Рассмотреть возможность перехода к задаче трансформации кода через добавление и планирование операций обновления и удаления узлов дерева разбора.
    \end{itemize}

  \item Реализация прототипа генератора систем инструментирования:
    \begin{itemize}[noitemsep]
      \item Разработать более гибкий подход к формированию новых разновидностей синтезируемых TXL функций (подобных R-, G-, W-функциям и т.д.).
      \item Использовать встроенный парсер языка TXL и описания пользовательских правил (например, на основе ANTLR~\cite{antlr}).
      \item Реализовать автоматический сбор подходящих узлов дерева разбора, основываясь на создаваемых пользователем <<переменных>>, а именно -- используемых при этом <<точек интереса>> (POI).
      \item Перенести КНФ решатель/преобразователь в C++ код.
      \item Расширить множество доступных типов переменных, определяемых пользователем.
      \item Реализовать описание и использование (in-place) текста врагмента одновременно для конкретной точки инструментирования.
    \end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выводы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе был рассмотрен процесс и результаты тестирования разработанного прототипа генератора систем автоматизации инструментирования программ.
Проведенные эксперименты на синтетических данных (исходных текстах программ) и проектах промышленного уровня показали работоспособность подхода и инструмента.
Были приведены замеченные в ходе тестирования недостатки и ограничения как прототипа, так и выбранного подхода, а также в заключении рассмотрены возможные способы дальнейшего развития данного прототипа.

