%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Обзор и анализ решений}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данном разделе рассматривается???

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Понятие инструментирования. Задача инструментирования}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Под инструментированием обычно понимают возможность отслеживания или установления количественных параметров программного продукта, а также возможность диагностировать ошибки и записывать информацию для отслеживания причин их возникновения посредством встраивания дополнительного (инструментирующего) кода в исследуемое ПО [1]

Наиболее распространенными областями применения инструментирования являются [2]:

\begin{itemize}
  \item трассировка;
  \item отладка;
  \item регистрация событий;
  \item подмена кода;
  \item счетчики производительности и др.
\end{itemize}

В зависимости от специфики используемого ЯП, среды его выполнения и доступности исходного текста инструментируемого ПО возможны три основных варианта инструментирования:

\begin{itemize}
  \item инструментирование на уровне исходного текста;
  \item инструментирование бинарного кода;
  \begin{itemize}
    \item инструментирование промежуточного кода;
    \item инструментирование машинного кода.
  \end{itemize}
\end{itemize}

Инструментирование на уровне исходного текста подразумевает вставку инструментального кода до компиляции (сборки) ПО.

Рассмотрим некоторые достоинства инструментирования исходного текста по сравнению с модификацией на уровне машинного кода [1]:
\begin{itemize}
  \item большая производительность, поскольку инструментальный код подвергается оптимизации вместе с кодом анализируемой программы;
  \item возможность отслеживания работы с высокоуровневыми объектами языка программирования (например, отслеживание состояния объектов в объектно-ориентированных языках).
\end{itemize}

Однако, данный метод инструментирования обладает рядом недостатков, ограничивающих его применимость [1]:
\begin{itemize}
  \item для выполнения анализа требуется сборка специального исполняемого образа, что неприменимо на поздних стадиях жизненного цикла программного продукта;
  \item сложность обработки взаимодействия инструментируемого и неинструментируемого кода (например, в случае использования разделяемых библиотек);
  \item сложность реализации инструментирования -- необходимость синтаксического анализа исходного текста с учетом индивидуальных особенностей компиляторов, нестандартных расширений языка и т.п.
\end{itemize}

Инструментирование на уровне бинарного кода подразумевает вставку инструментального кода во время компиляции (на одном из этапов) или после получения финальных артефактов сборки (исполняемых файлов).

Инструментирование на уровне бинарного кода обладает следующими преимуществами [1]:
\begin{itemize}
  \item Большая гибкость -- независимость от языка программирования и отсутствие требования наличия исходных текстов. Возможно применение к итоговым образам на поздних этапах жизненного цикла продукта.
  \item Анализ с точностью до инструкции и до каждого доступа к памяти.
  \item Анализ программы после применения всех оптимизаций компилятора, позволяющий обнаруживать ошибки в итоговых исполняемых образах, включая ошибки компилятора.
  \item Простота использования -- не требуется специальная сборка ПО, достаточен запуск под подходящей виртуальной машиной.
  \item Программная система обрабатывается в целом -- инструментированию подвергается как сам тестируемый модуль, так и все используемые им стандартные средства, что позволяет учесть преобразования данных, осуществляемые в стандартных подпрограммах.
\end{itemize}

Недостатки инструментирования бинарного кода [1]:
\begin{itemize}
  \item меньшая производительность по сравнению с методами, работающими на уровне исходных текстов;
  \item сложность сопоставления машинных инструкций и операторов исходного языка программирования (для этого используется отладочная информация, однако это вызывает трудности в случае применения флагов оптимизации при сборке исходного ПО).
\end{itemize}

Ниже рассмотрен упрощенный пример задачи, которая часто решается путем инструментирования требуемого фрагмента или полного исходного кода программного продукта.

Пусть дан следующий фрагмент исходного текста (функция) на некотором языке программирования (в данном случае -- JavaScript) [2]:
\begin{lstlisting}[frame=single, language=Java]
function foo(a) {
    if (a > 5) {
        return 1;
    } else {
        return 2;
    }
}
\end{lstlisting}

Задача: необходимо выяснить, сколько раз и какие строки этого фрагмента (тела функции) выполняются при проведении тестирования некоторым тестом ''А'' (содержимое и результаты работы теста не рассматриваются; подразумевается, что тест сравнивает результат работы вызова этой функции с некоторыми аргументами с каким-то, заранее заданным, фиксированным значением).

Решение: разместим вызовы некоторой функции ''\lstinline{__visit(x)}'', где x -- номер строки или порядковый номер отслеживаемой точки, перед каждой интересующей строкой, число исполнений которой необходимо определить.

Результатом такого преобразования будет являться следующий исходный текст:
\begin{lstlisting}[frame=single, language=Java]
function foo(a) {
    __visit(1);
    if (a > 5) {
        __visit(2);
        return 1;
    } else {
        __visit(3);
        return 2;
    }
}
\end{lstlisting}

В приведенном выше примере аргументами функции ''\lstinline{__visit(x)}'' является порядковые номера частей, количество раз выполнения которых необходимо найти.
Сама функция ''\lstinline{__visit(x)}'' в данном примере будет иметь следующий вид [2]:
\begin{lstlisting}[frame=single, language=Java]
// количество нулей соответствует общему количеству точек в исходном тексте, число исполнений которых необходимо измерить
var __count = [0, 0, 0, ...];

window.__visit = function(idx) {
    __count[idx - 1]++;
};
\end{lstlisting}

В данном случае массив ''\lstinline{__count}'' по окончании работы теста ''А'' будет содержать число вызовов функции ''\lstinline{__visit(x)}'', и соответственно, количество раз, сколько были выполнены интересующие строки исходного фрагмента кода.

В таблице~\ref{table:insrtExampleResults} приведен пример определения целевого показателя (число исполнений каждой строки исходного фрагмента).
\begin{table}
  \captionsetup{skip=5pt}
  \caption{Пример сопоставления результатов}
  \label{table:insrtExampleResults}
  \centering
  \begin{tabular}{|c|c|c|c|}
    \hline
    \# п.п., i  & Исходный участок            & \lstinline!__count[i]!  & Число исполнений  \\ \hline
    1           & \lstinline!if (a > 5)!      & 10                      & 10                \\ \hline
    2           & \lstinline!{ return 1; }!   & 7                       & 7                 \\ \hline
    3           & \lstinline!{ return 2; }!   & 3                       & 3                 \\ \hline
  \end{tabular}
\end{table}

Как видно из результатов, примененный способ ценой дополнительных расходов памяти на хранение массива ''\lstinline{__count}'' решает поставленную задачу.

Схожим способом моно решить задачу определения времени исполнения каждого блока (и отдельно взятой строки) в исходном тексте, промежуточном представлении или даже машинном коде инструментируемого ПО, вместе с множеством других задач, которые требуют встраивание небольших фрагментов кода в какие-то заранее определенные области исходного кода.

Однако, для масштабного и частого применения данного метода необходимы средства, позволяющие в автоматическом режиме произвести подобные трансформации с исходным текстом, промежуточным представлением или машинным представлением, в зависимости от специфики ЯП и доступности исходного текста.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Обзор}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Далее будут рассмотрены с позиции различных критериев некоторые существующие автоматизированные системы инструментирования, позволяющие произвести инструментирование исходных текстов программного обеспечения.

%%%%%%%%%%%%%%%%%%%%%%
\subsection{Критерии обзора}
%%%%%%%%%%%%%%%%%%%%%%

Выделим следующие критерии сравнения систем инструментирования:
\begin{itemize}
  \item поддерживаемые языки программирования;
  \item ???
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%
\subsection{GCC Gcov}
%%%%%%%%%%%%%%%%%%%%%%
Свободно распространяемая утилита gcov предоставляет информацию о том, сколько раз исполнился во время работы программы каждый участок исходного текста ПО. Утилита создает файл с анализом покрытия кода для программ, инструментированных с помощью опций ''-fprofile-arcs -ftest-coverage'' компиляторов в составе GCC (первая опция приводит к сохранению статистики исполнения каждой строки исходного файла, а вторая -- статистики ветвлений) [3], что является основой её функционирования.

Важным ограничением возможностей утилиты является требование об отключении опций оптимизации при сборке инструментируемого ПО, что иначе приведет к некорректным, неполным или неожиданным результатам [3].

После запуска инструментированной программы будет создано несколько файлов с расширениями ''.bb'', ''.bbg'', ''.da'', которые в последствии будут анализироваться gcov. Утилита принимает в качестве аргумента командной строки имена файлов с исходными текстами и производит аннотированный листинг: перед каждой строкой исходного кода указывается количество её исполнений, строки, которые не исполнялись, помечаются префиксом ''\#\#\#\#\#'' [3].

%%%%%%%%%%%%%%%%%%%%%%
\subsection{Testwell CTC++ Preprocessor}
%%%%%%%%%%%%%%%%%%%%%%
Testwell CTC++ -- это коммерческая система инструментального покрытия кода и динамического анализа для кода C и C++. С некоторыми дополнительными компонентами CTC ++ можно использовать также для C\#, Java и Objective-C. Кроме того, CTC ++ может использоваться для анализа кода на встраиваемых машинах, в том числе с ограничениями по ресурсам (малое количество памяти, отсутствие ОС и др.). Система обеспечивает покрытие кода для отдельных строк, выражений, функций, ветвлений, [4].

Утилита CTC++ Preprocessor (ctc) используется для инструментирования и компиляции представляющих интерес исходных файлов C или C++ и для связывания инструментированной программы с библиотекой времени выполнения CTC++. На этом этапе ctc поддерживает файл символов ''MON.sym'', где сохраняются имена инструментированных файлов и их содержимое [4].

Система CTC++ используется вместо стандартного компилятора, предоставляя собственный для используемого ЯП, что позволяет гибко встраивать инструментальный код.

%%%%%%%%%%%%%%%%%%%%%%
\subsection{BullseyeCoverage}
%%%%%%%%%%%%%%%%%%%%%%
Схожим образом работает система BullseyeCoverage, используя при этом компилятор Microsoft C++ для сборки инструментированного кода, что расширяет возможности для инструментирования под разные процессоры и платформы, которые поддерживаются этим компилятором [5].

%%%%%%%%%%%%%%%%%%%%%%
\subsection{Google Web Tracing Framework}
%%%%%%%%%%%%%%%%%%%%%%
Web Tracing Framework (WTF) -- это набор библиотек, инструментов и сценариев, предназначенных для веб-разработчиков, пытающихся писать большие, чувствительные к производительности приложения Javascript. Он предназначен для использования вместе со встроенными инструментами разработки браузеров [6]. 

WTF предоставляет возможности по перехвату событий, инструментированию кода, трассировки и отображения собранной статистики посредством встроенных возможностей среды исполнения JavaScript, в частности, браузера Google Chrome [6]. Инструментирование осуществляется вызовом специализированных функций этой библиотеки.

%%%%%%%%%%%%%%%%%%%%%%
\subsection{Froglogic Squish Coco CoverageScanner}
%%%%%%%%%%%%%%%%%%%%%%
Squish Coco -- это многоязычный (Tcl, QML, C\#, C/C++) инструмент для автоматической оценки покрытия исходного кода, используемый для измерения охвата тестов блоков, ветвлений и условных выражений.

На рисунке 1 приведена обобщенная схема процесса инструментирования и отображения результатов.
 
Рис. 1. Обобщенная схема работы Coco [7]

Утилита CoverageScanner осуществляет анализ, предобработку и инструментирование временной копии исходного текста, который впоследствии перенаправляется выбранному компилятору. Гибкость создается благодаря подмене с помощью скриптов (командных сценариев) вызовов компиляторов и средств сборки так, чтобы одним (первым) из этапов сборки оказалась утилита CoverageScanner [7].

%%%%%%%%%%%%%%%%%%%%%%
\subsection{Пример разработки собственной системы инструментирования}
%%%%%%%%%%%%%%%%%%%%%%
В статье [8] рассматривается пошаговое создание простейшего собственного средства инструментирования для ЯП Java на основе библиотеки для анализа, обработки и генерации кода JavaParser [9].

Основная идея заключается в создании, как в случае Squish Coco, программы-препроцессора, которая применяет выбранные программистом трансформации к исходному тексту и сохраняет результат для последующей компиляции стандартным компилятором языка (в данном случае -- Java).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Итоги}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В таблице~\ref{table:valuesCompare} собраны ??? в соответствии с критериями обзора.
\begin{table}
  \captionsetup{skip=5pt}
  \caption{Пример сопоставления результатов}
  \label{table:valuesCompare}
  \centering
  \begin{tabular}{|l|c|c|c|}
    \hline
    Название системы                      & Поддерживаемые языки  \\ \hline
    GCC Gcov                              & C/C++                 \\ \hline
    Testwell CTC++ Preprocessor           & C/C++                 \\ \hline
    BullseyeCoverage                      & C/C++                 \\ \hline
    Google Web Tracing Framework          & JavaScript            \\ \hline
    Froglogic Squish Coco CoverageScanner & Tcl, QML, C\#, C/C++  \\ \hline
    ???                                   & ???                   \\ \hline
  \end{tabular}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выводы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данной работе было проведено ознакомление с понятием инструментирования, приведены достоинства и недостатки различных видов инструментирования, рассмотрен простейший пример процесса инструментирования программного обеспечения и выполнен краткий обзор некоторых существующих средств, позволяющих выполнять этот процесс автоматически для программных продуктов, созданных с использованием различных языков программирования.
