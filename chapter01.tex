%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Обзор и анализ решений}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Под инструментированием обычно понимают возможность отслеживания или установления количественных параметров программного продукта, а также возможность диагностировать ошибки и записывать информацию для отслеживания причин их возникновения посредством встраивания дополнительного (инструментирующего) кода в исследуемое ПО [1]

Наиболее распространенными областями применения инструментирования являются [2]:

\begin{itemize}
  \item трассировка;
  \item отладка;
  \item регистрация событий;
  \item подмена кода;
  \item счетчики производительности и др.
\end{itemize}

В зависимости от специфики используемого ЯП, среды его выполнения и доступности исходного текста инструментируемого ПО возможны три основных варианта инструментирования:

\begin{itemize}
  \item инструментирование на уровне исходного текста;
  \item инструментирование бинарного кода;
  \begin{itemize}
    \item инструментирование промежуточного кода;
    \item инструментирование машинного кода.
  \end{itemize}
\end{itemize}

Инструментирование на уровне исходного текста подразумевает вставку инструментального кода до компиляции (сборки) ПО.

Рассмотрим некоторые достоинства инструментирования исходного текста по сравнению с модификацией на уровне машинного кода [1]:
\begin{itemize}
  \item большая производительность, поскольку инструментальный код подвергается оптимизации вместе с кодом анализируемой программы;
  \item возможность отслеживания работы с высокоуровневыми объектами языка программирования (например, отслеживание состояния объектов в объектно-ориентированных языках).
\end{itemize}

Однако, данный метод инструментирования обладает рядом недостатков, ограничивающих его применимость [1]:
\begin{itemize}
  \item для выполнения анализа требуется сборка специального исполняемого образа, что неприменимо на поздних стадиях жизненного цикла программного продукта;
  \item сложность обработки взаимодействия инструментируемого и неинструментируемого кода (разделяемые библиотеки);
  \item сложность реализации инструментирования -- необходимость синтаксического анализа исходного текста с учетом индивидуальных особенностей компиляторов, нестандартных расширений языка и т. п.
\end{itemize}

Инструментирование на уровне бинарного кода подразумевает вставку инструментального кода во время компиляции (на одном из этапов) или после получения финальных артефактов сборки (исполняемых файлов).

Инструментирование на уровне машинного кода обладает следующими преимуществами [1]:
\begin{itemize}
  \item Большая гибкость -- независимость от языка программирования и отсутствие требования наличия исходных текстов. Возможно применение к итоговым образам на поздних этапах жизненного цикла продукта.
  \item Анализ с точностью до инструкции и до каждого доступа к памяти.
  \item Анализ программы после применения всех оптимизаций компилятора, позволяющий обнаруживать ошибки в итоговых исполняемых образах, включая ошибки компилятора.
  \item Простота использования -- не требуется специальная сборка ПО, достаточен запуск под подходящей виртуальной машиной.
  \item Программная система обрабатывается в целом -- инструментированию подвергается как сам тестируемый модуль, так и все используемые им стандартные средства, что позволяет учесть преобразования данных, осуществляемые в стандартных подпрограммах.
\end{itemize}

Недостатки инструментирования бинарного кода [1]:
\begin{itemize}
  \item меньшая производительность по сравнению с методами, работающими на уровне исходных текстов;
  \item сложность сопоставления машинных инструкций и операторов исходного языка программирования (для этого используется отладочная информация, однако это вызывает трудности в случае применения флагов оптимизации при сборке исходного ПО).
\end{itemize}

Ниже рассмотрен упрощенный пример задачи, которая часто решается путем инструментирования требуемого фрагмента или полного исходного кода программного продукта.

Пусть дан следующий фрагмент исходного текста (функция) на некотором языке программирования (в данном случае -- JavaScript) [2]:

\begin{lstlisting}[frame=single, language=Java]
function foo(a) {
    if (a > 5) {
        return 1;
    } else {
        return 2;
    }
}
\end{lstlisting}

Задача: необходимо выяснить, сколько раз и какие строки этого фрагмента (тела функции) выполняются при проведении тестирования некоторым тестом "А" (содержимое и результаты работы теста не рассматриваются; подразумевается, что тест сравнивает результат работы вызова этой функции с некоторыми аргументами с каким-то, заранее заданным, фиксированным значением).

Решение: разместим вызовы некоторой функции "\_\_visit(x)", где x -- номер строки или порядковый номер отслеживаемой точки, перед каждой интересующей строкой, число исполнений которой необходимо определить.

Результатом такого преобразования будет являться следующий исходный текст:

\begin{lstlisting}[frame=single, language=Java]
function foo(a) {
    __visit(1);
    if (a > 5) {
        __visit(2);
        return 1;
    } else {
        __visit(3);
        return 2;
    }
}
\end{lstlisting}

В приведенном выше примере аргументами функции "\_\_visit(x)" является порядковые номера частей, количество раз выполнения которых необходимо найти.
Сама функция "\_\_visit(x)" в данном примере будет иметь следующий вид [2]:

\begin{lstlisting}[frame=single, language=Java]
var __count = [0, 0, 0, ...]; // столько нулей, сколько частей в коде,
                              // которые интересуют
window.__visit = function(idx) {
    __count[idx - 1]++;
};
\end{lstlisting}

В данном случае массив "\_\_count" по окончании работы теста "А" будет содержать число вызовов функции "\_\_visit(x)", и соответственно, количество раз, сколько были выполнены интересующие строки исходного фрагмента кода.

Ниже приведен пример определения целевого показателя (число исполнений каждой строки исходного фрагмента).
Таблица 1. Пример сопоставления результатов
\# п.п., i  Исходный участок  \_\_counti  Число исполнений
1  if (a > 5)  10  10
2  { return 1; }  7  7
3  { return 2; }  3  3

Как видно из результатов, примененный способ ценой дополнительных расходов памяти на хранение массива "\_\_count" решает поставленную задачу.

Схожим способом моно решить задачу определения времени исполнения каждого блока (и отдельно взятой строки) в исходном тексте, промежуточном представлении или даже машинном коде инструментируемого ПО, вместе с множеством других задач, которые требуют встраивание небольших фрагментов кода в какие-то заранее определенные области исходного кода.

Однако, для масштабного и частого применения данного метода необходимы средства, позволяющие в автоматическом режиме произвести подобные трансформации с исходным текстом, промежуточным представлением или машинным представлением, в зависимости от специфики ЯП и доступности исходного текста.

1.3. Автоматизированные системы инструментирования
Далее будут рассмотрены некоторые существующие системы автоматизации инструментирования.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Критерии обзора}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Текст.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Обзор}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

1.3.1 Инструментирование исходного текста

%%%%%%%%%%%%%%%%%%%%%%
\subsection{GCC Gcov}
%%%%%%%%%%%%%%%%%%%%%%
Свободно распространяемая утилита gcov предоставляет информацию о том, сколько раз исполнился во время работы программы каждый участок исходного текста ПО. Утилита создает файл с анализом покрытия кода для программ, инструментированных с помощью опций "-fprofile-arcs -ftest-coverage" компиляторов в составе GCC (первая опция приводит к сохранению статистики исполнения каждой строки исходного файла, а вторая -- статистики ветвлений) [3], что является основой её функционирования.

Важным ограничением возможностей утилиты является требование об отключении опций оптимизации при сборке инструментируемого ПО, что иначе приведет к некорректным, неполным или неожиданным результатам [3].

После запуска инструментированной программы будет создано несколько файлов с расширениями ".bb", ".bbg", ".da", которые в последствии будут анализироваться gcov. Утилита принимает в качестве аргумента командной строки имена файлов с исходными текстами и производит аннотированный листинг: перед каждой строкой исходного кода указывается количество её исполнений, строки, которые не исполнялись, помечаются префиксом "\#\#\#\#\#" [3].

%%%%%%%%%%%%%%%%%%%%%%
\subsection{Testwell CTC++ Preprocessor}
%%%%%%%%%%%%%%%%%%%%%%
Testwell CTC++ -- это коммерческая система инструментального покрытия кода и динамического анализа для кода C и C++. С некоторыми дополнительными компонентами CTC ++ можно использовать также для C\#, Java и Objective-C. Кроме того, CTC ++ может использоваться для анализа кода на встраиваемых машинах, в том числе с ограничениями по ресурсам (малое количество памяти, отсутствие ОС и др.). Система обеспечивает покрытие кода для отдельных строк, выражений, функций, ветвлений, [4].

Утилита CTC++ Preprocessor (ctc) используется для инструментирования и компиляции представляющих интерес исходных файлов C или C++ и для связывания инструментированной программы с библиотекой времени выполнения CTC++. На этом этапе ctc поддерживает файл символов "MON.sym", где сохраняются имена инструментированных файлов и их содержимое [4].

Система CTC++ используется вместо стандартного компилятора, предоставляя собственный для используемого ЯП, что позволяет гибко встраивать инструментальный код.

%%%%%%%%%%%%%%%%%%%%%%
\subsection{BullseyeCoverage}
%%%%%%%%%%%%%%%%%%%%%%
Схожим образом работает система BullseyeCoverage, используя при этом компилятор Microsoft C++ для сборки инструментированного кода, что расширяет возможности для инструментирования под разные процессоры и платформы, которые поддерживаются этим компилятором [5].

%%%%%%%%%%%%%%%%%%%%%%
\subsection{Google Web Tracing Framework}
%%%%%%%%%%%%%%%%%%%%%%
Web Tracing Framework (WTF) -- это набор библиотек, инструментов и сценариев, предназначенных для веб-разработчиков, пытающихся писать большие, чувствительные к производительности приложения Javascript. Он предназначен для использования вместе со встроенными инструментами разработки браузеров [6]. 

WTF предоставляет возможности по перехвату событий, инструментированию кода, трассировки и отображения собранной статистики посредством встроенных возможностей среды исполнения JavaScript, в частности, браузера Google Chrome [6]. Инструментирование осуществляется вызовом специализированных функций этой библиотеки.

%%%%%%%%%%%%%%%%%%%%%%
\subsection{Froglogic Squish Coco CoverageScanner}
%%%%%%%%%%%%%%%%%%%%%%
Squish Coco -- это многоязычный (Tcl, QML, C\#, C/C++) инструмент для автоматической оценки покрытия исходного кода, используемый для измерения охвата тестов блоков, ветвлений и условных выражений.

На рисунке 1 приведена обобщенная схема процесса инструментирования и отображения результатов.
 
Рис. 1. Обобщенная схема работы Coco [7]

Утилита CoverageScanner осуществляет анализ, предобработку и инструментирование временной копии исходного текста, который впоследствии перенаправляется выбранному компилятору. Гибкость создается благодаря подмене с помощью скриптов (командных сценариев) вызовов компиляторов и средств сборки так, чтобы одним (первым) из этапов сборки оказалась утилита CoverageScanner [7].

%%%%%%%%%%%%%%%%%%%%%%
\subsection{Пример разработки собственной системы инструментирования}
%%%%%%%%%%%%%%%%%%%%%%
В статье [8] рассматривается пошаговое создание простейшего собственного средства инструментирования для ЯП Java на основе библиотеки для анализа, обработки и генерации кода JavaParser [9].

Основная идея заключается в создании, как в случае Squish Coco, программы-препроцессора, которая применяет выбранные программистом трансформации к исходному тексту и сохраняет результат для последующей компиляции стандартным компилятором языка (в данном случае -- Java).

--------------------------------------------

1.3.2 Инструментирование машинного кода
1.3.2.1 Intel Pin
Pin -- это инструментарий для динамической обработки и анализа двоичных исполняемых файлов для архитектур процессоров IA-32, x86-64 и MIC [10].

Pin предоставляет API, который абстрагирует основные идиосинкразии набора команд и позволяет передавать контекстную информацию, такую как содержимое регистра, в введенный код в качестве параметров. Pin автоматически сохраняет и восстанавливает регистры, которые перезаписываются вставленным кодом, что позволяет приложению продолжать работать. Доступен ограниченный доступ к символам и отладочной информации [10].

Pin поддерживает два режима инструментирования [11]:
\begin{itemize}
  \item JIT,
  \item Probe.
\end{itemize}

Режим JIT поддерживает все функции Pin, в то время как режим Probe поддерживает ограниченный набор функций, но гораздо быстрее, почти не увеличивая время работы программы. В режиме "JIT" используется компилятор "just-in-time", чтобы перекомпилировать весь программный код и вставить необходимый код, а в режиме "Probe" используются специально подготовленные (во время компиляции при использовании компилятора Intel или перед запуском ПО) трамплины для внедрения кода.

1.3.2.2 DynamoRIO
DynamoRIO -- это система манипулирования кодом времени выполнения, которая поддерживает преобразования кода в любой части программы во время ее выполнения. DynamoRIO предоставляет интерфейс для создания динамических инструментов для разных целей: анализа и понимания программ, профилирования, инструментирования, оптимизации, перевода и т.д. В отличие от многих систем динамических инструментов, DynamoRIO не ограничивается вставкой выносок/трамплинов и допускает произвольные модификации инструкций через библиотеку манипулирования инструкциями. DynamoRIO обеспечивает управление приложениями, работающими в операционных системах Windows, Linux или Android, и процессорах с архитектурами IA-32, AMD64, ARM и AArch64 [12].

DynamoRIO представляет собой подобие виртуальной машины, перенаправляя выполнение программы из исходного двоичного кода в копию этого кода. Инструментирующий код, выполняющий требуемые полезные действия, затем добавляется к этой копии. В оригинальную программу не вносятся изменения. DynamoRIO работает полностью во время выполнения и может обрабатывать устаревший код, динамически загружаемые библиотеки, динамически генерируемый код и самоизменяющийся код. Высокая производительность достигается благодаря динамической адаптивной оптимизации [13].

API DynamoRIO абстрагируется от деталей процесса виртуализации и фокусируется на мониторинге или изменении потока кода ПО. Инструмент может вставлять в программу трамплины, которые вызывают обработчики инструмента в требуемых точках программы. Инструмент также может вставлять инструментальный код на уровне языка ассемблера, что обеспечивает детальный контроль над действиями инструмента и его работой. DynamoRIO поддерживает адаптивную оптимизацию и адаптивное инструментирование, позволяя инструменту удалять или модифицировать код в любой точке ПО на протяжении всего выполнения целевой программы [13].

1.3.2.3 Valgrind
Valgrind -- это инструментальная среда для создания инструментов динамического анализа. Существуют инструменты Valgrind, которые могут автоматически обнаруживать многие ошибки управления памятью и потоков, а также подробно описывать ПО [14].

Valgrind применяет схожую технику, что и DynamoRIO -- запуск По на виртуальном процессоре и трансляция x86 ассемблерного кода в промежуточное представление (UCode) и обратно в x86 ассемблерный (машинный) код посредством JIT компилятора [15].

1.3.2.4 Frida
Frida -- это система динамического инструментирования ПО. Она позволяет вставлять фрагменты JavaScript или библиотеку в приложения для операционных систем Windows, macOS, GNU/Linux, iOS, Android и QNX. Frida также предоставляет несколько инструментов, созданных поверх Frida API [16].

Ядро Frida написано на C и производит внедрение интерпретатора JavaScript, Google V8, в целевые процессы, где JS выполняется с полным доступом к памяти, перехватом функций и вызовом собственных функций внутри процесса. Система позволяет внедрять фрагменты кода на JS, Python, C, Swift, языках семейства ".Net", Qml и др [16].

Ядро Frida основывается на использовании библиотеки frida-gum [17] для модификации и встраивания машинного кода в машинный код целевого ПО, что позволяет встроить "агента", который взаимодействует с машинным кодоп инструментируемого ПО и встраиваемой программы на JavaScript [18]. Используемая библиотека позволяет производить обработку кода для процессоров с архитектурами ARM, AArch64, MIPS и x86 [17].

1.3.3 Инструментирование промежуточного кода
1.3.3.1 OpenCover
OpenCover -- это инструмент оценки покрытия кода для платформы ".Net" версии 2 и выше (для ОС Windows), поддерживающий 32- и 64-битные процессоры, позволяющий выполнять инструментирование как последовательных, так и ветвящихся участков кода [19].

OpenCover использует встроенные возможности инструментирования и декодирования промежуточного IL кода платформы ".Net", такие как PDB файлы, а также классы и методы библиотеки Mono.Cecil [20].

1.3.3.2 Equip
Equip -- это небольшая библиотека, которая позволяет проводить инструментирование байт-кода программ, написанных на языке Python [21].

Основой библиотеки является набор классов функций, позволяющих производить разбор, анализ и манипулирование байт-кодом файлов "*.pyc" при помощи стандартных модулей среды выполнения Python, таких как opcode, types, traceback, imp и других. Пользователю библиотеки предлагается написание класса-посетителя (шаблон проектирования "Visitor"), который выполнит вставку инструментирующего кода в определяемых пользователях участках байт-кода [21]:

\begin{itemize}
  \item BEFORE: перед любым другим байт-кодом
  \item AFTER: перед каждым возвратом значения (RETURN\_VALUE)
  \item LINENO: когда встречается заданный номер строки
  \item MODULE\_ENTER: в самом начале модуля
  \item MODULE\_EXIT: в самом конце модуля
\end{itemize}

Вместе с перечисленным выше, библиотека позволяет производить добавление зависимостей с помощью вызова "SimpleRewriter.insert\_import".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Итоги}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Текст.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выводы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

В данной работе было проведено ознакомление с понятием инструментирования, приведены достоинства и недостатки различных видов инструментирования, рассмотрен простейший пример процесса инструментирования программного обеспечения и выполнен краткий обзор некоторых существующих средств, позволяющих выполнять этот процесс автоматически для программных продуктов, созданных с использованием различных языков программирования.
